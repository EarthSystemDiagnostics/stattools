#' Temperature distribution of seasonal cycle
#'
#' Probability density function and random number generation for the temperature
#' distribution in the seasonal cycle.
#'
#' The seasonal temperature cycle is approximated as a sine wave with gaussian
#' noise. The probability density function is obtained by numerically
#' convolving a scaled sine wave with a normal PDF with mean equal to 0. Random
#' deviates are generated by adding gaussian noise to points sampled uniformly
#' from the scaled sine wave on the interval 0 to 2*pi.
#'
#' @param x numeric; vector of temperatures.
#' @param mean.t numeric; mean annual temperature.
#' @param amp.t numeric; peak-to-peak amplitude of the seasonal cycle in
#'   temperature.
#' @param sd.t numierc; inter-annual standard deviation of the temperature at a
#'   given point in the seasonal cycle.
#' @param return return either the densities for the temperatures \code{x}, or a
#'   function to do so; default: c("density", "FUN").
#' @param res numeric; resolution of the temperature vectors to be convolved;
#'   default is 0.01.
#' @param n integer; number of samples.
#' @name SeasonalCycle
#' @author Andrew Dolman <andrew.dolman@awi.de>
#' @examples
#' \dontrun{
#' if(interactive()){
#' amp.t <- 10
#' mean.t <- 25
#' sd.t <- 0.75
#'
#' x <- seq(mean.t - amp.t, mean.t + amp.t, length.out = 1000)
#' Z <- rSeas(n = 100000, mean.t, amp.t, sd.t)
#'
#' hist(Z, freq=F,breaks=100)
#' lines(x, dSeas(x, mean.t, amp.t, sd.t, res = 0.1), col = "Blue")
#' lines(x, dSeas(x, mean.t, amp.t, sd.t, res = 0.01), col = "Green")
#' lines(x, dSeas(x, mean.t, amp.t, sd.t, res = 0.001), col = "Red")
#'  }
#'}
NULL

#' @rdname SeasonalCycle
#' @export
dSeas <- function(x = NULL, mean.t, amp.t, sd.t,
                  return = c("density", "FUN"), res = 0.01) {

  rng <- max(c(amp.t, sd.t * 5))
  lnth <- (2 * rng) / res

  # make vector length with many factors for fast FFT
  lnth2 <- (2 ^ ceiling(log(lnth, base = 2)))

  if (lnth2 > 5000) {
    warning("Sequences to be convolved are very long, ",
            "decrease the resolution or rescale 'mean.t' and 'amp.t'.")
  }

  # calculate new resolution for scaling
  res2 <- (2 * rng) / lnth2

  xin <- seq(mean.t - rng, mean.t + rng, length.out = lnth2)
  zin <- dSin(xin, mean.t, amp.t)

  yin <- stats::dnorm(xin, mean.t, sd.t)

  cv <- stats::convolve(zin, yin, type = "open")
  cv <- cv / (sum(cv) * res2)

  x2 <- seq(mean.t - 2 * rng, mean.t + 2 * rng, length.out = length(cv))

  FUN <- stats::approxfun(x2, cv, yleft = 0, yright = 0)

  ret <- match.arg(return)

  switch(ret,
         density = return(FUN(x)),
         FUN = return(FUN))
}

#' @rdname SeasonalCycle
#' @export
rSeas <- function(n, mean.t, amp.t, sd.t){
  x <- stats::runif(n, 0, 2*pi)
  y <- mean.t + sin(x) * amp.t/2
  z <- y + stats::rnorm(n, 0, sd.t)
  return(z)
}



#' Probability density of scaled sine wave
#'
#' Calculate the probability density for a scaled sine wave.
#'
#' @param x numeric; vector of values for which to obtain the probability
#'   densities.
#' @param mean.t numeric; mean of the sine wave.
#' @param amp.t numeric; peak-to-peak amplitude of the sine wave.
#' @return Numeric vector of probability density values for the values given in
#'   \code{x}. Values in \code{x} outside the sine wave's envelope obtain zero
#'   probability.
#' @author Andrew Dolman <andrew.dolman@awi.de>
#' @export
dSin <- function(x, mean.t, amp.t) {

  d <- rep(0, length(x))

  # Do not evaluate where known to be NaN
  ind <- x > (mean.t - amp.t / 2) & x < (mean.t + amp.t / 2)
  d[ind] <- 1 / (pi * sqrt(1 - ((2 * x[ind]) / amp.t - (2 * mean.t) / amp.t) ^ 2))

  2 * d / amp.t
}
