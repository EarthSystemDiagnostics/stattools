#' Temperature distribution of seasonal cycle
#'
#' Probability density function and random number generation for the temperature
#' distribution in the seasonal cycle.
#'
#' The seasonal temperature cycle is approximated as a sine wave with gaussian
#' noise. The probability density function is obtained by numerically
#' convolving a scaled sine wave with a normal PDF with mean equal to 0. Random
#' deviates are generated by adding gaussian noise to points sampled uniformly
#' from the scaled sine wave on the interval 0 to 2*pi.
#'
#' @param x numeric; vector of temperatures.
#' @param mean.t numeric; mean annual temperature.
#' @param amp.t numeric; peak-to-peak amplitude of the seasonal cycle in
#'   temperature.
#' @param sd.t numierc; inter-annual standard deviation of the temperature at a
#'   given point in the seasonal cycle.
#' @param return return either the densities for the temperatures \code{x}, or a
#'   function to do so; default: c("density", "FUN").
#' @param res numeric; resolution of the temperature vectors to be convolved;
#'   default is 0.01.
#' @param n integer; number of samples.
#' @name SeasonalCycle
#' @author Andrew Dolman <andrew.dolman@awi.de>
#' @examples
#' \dontrun{
#' if(interactive()){
#' amp.t <- 10
#' mean.t <- 25
#' sd.t <- 0.75
#'
#' x <- seq(mean.t - amp.t, mean.t + amp.t, length.out = 1000)
#' Z <- rSeas(n = 100000, mean.t, amp.t, sd.t)
#'
#' hist(Z, freq=F,breaks=100)
#' lines(x, dSeas(x, mean.t, amp.t, sd.t, res = 0.1), col = "Blue")
#' lines(x, dSeas(x, mean.t, amp.t, sd.t, res = 0.01), col = "Green")
#' lines(x, dSeas(x, mean.t, amp.t, sd.t, res = 0.001), col = "Red")
#'  }
#'}
NULL

#' @rdname SeasonalCycle
#' @export
dSeas <- function(x = NULL, mean.t, amp.t, sd.t,
                  return = c("density", "FUN"), res = 0.01) {

  rng <- max(c(amp.t, sd.t * 5))
  lnth <- (2 * rng) / res

  # make vector length with many factors for fast FFT
  lnth2 <- (2 ^ ceiling(log(lnth, base = 2)))

  if (lnth2 > 5000) {
    warning("Sequences to be convolved are very long, ",
            "decrease the resolution or rescale 'mean.t' and 'amp.t'.")
  }

  # calculate new resolution for scaling
  res2 <- (2 * rng) / lnth2

  xin <- seq(mean.t - rng, mean.t + rng, length.out = lnth2)
  zin <- dSin(xin, mean.t, amp.t)

  yin <- stats::dnorm(xin, mean.t, sd.t)

  cv <- stats::convolve(zin, yin, type = "open")
  cv <- cv / (sum(cv) * res2)

  x2 <- seq(mean.t - 2 * rng, mean.t + 2 * rng, length.out = length(cv))

  FUN <- stats::approxfun(x2, cv, yleft = 0, yright = 0)

  ret <- match.arg(return)

  switch(ret,
         density = return(FUN(x)),
         FUN = return(FUN))
}

#' @rdname SeasonalCycle
#' @export
rSeas <- function(n, mean.t, amp.t, sd.t){
  x <- stats::runif(n, 0, 2*pi)
  y <- mean.t + sin(x) * amp.t/2
  z <- y + stats::rnorm(n, 0, sd.t)
  return(z)
}

#' Probability density of scaled sine wave
#'
#' Calculate the probability density for a scaled sine wave.
#'
#' @param x numeric; vector of values for which to obtain the probability
#'   densities.
#' @param mean.t numeric; mean of the sine wave.
#' @param amp.t numeric; peak-to-peak amplitude of the sine wave.
#' @return Numeric vector of probability density values for the values given in
#'   \code{x}. Values in \code{x} outside the sine wave's envelope obtain zero
#'   probability.
#' @author Andrew Dolman <andrew.dolman@awi.de>
#' @export
dSin <- function(x, mean.t, amp.t) {

  d <- rep(0, length(x))

  # Do not evaluate where known to be NaN
  ind <- x > (mean.t - amp.t / 2) & x < (mean.t + amp.t / 2)
  d[ind] <- 1 / (pi * sqrt(1 - ((2 * x[ind]) / amp.t - (2 * mean.t) / amp.t) ^ 2))

  2 * d / amp.t
}

#' Summarise empirical distribution
#'
#' Summarise an empirical probability distribution function.
#'
#' Calculation of the mode is naive. For a multimodal distribution only the
#' highest is returned, in the case of 2 or more modes with exactly the same
#' probability, the first is returned.
#'
#' @param x numeric; vector of values of the empirical PDF.
#' @param p numeric; vector of probabilities of the empirical PDF.
#' @return Returns a named vector with the mean, median, mode, and standard
#' deviation of the empirical PDF.
#' @author Andrew Dolman <andrew.dolman@awi.de>
#' @examples
#' df <- data.frame(x = 1:10)
#' df$p <- dnorm(df$x, 5, 2)
#' SummariseEmpiricalPDF(df$x, df$p)
#' @export
SummariseEmpiricalPDF <- function(x, p) {

  # Ensure x and p are sorted
  p <- p[order(x)]
  x <- sort(x)

  # Ensure p sum to 1
  p <- p / sum(p)

  # Mean
  w.mean <- sum(x * p)

  # SD
  M <- sum(p > 0)
  w.sd <- sqrt(sum(p * (x - w.mean)^2) / ((M - 1)/ M * sum(p)))

  # Median
  csum.p <- cumsum(p)
  med.ind <- which.min(abs(csum.p - 0.5))
  w.median <- x[med.ind]

  # Mode
  max.wt <- max(p)
  n.max <- sum(p == max.wt)
  if (n.max > 1) {
    warning(paste0(n.max,
                   " x with equal maximum probability. Returning the first"))
  }
  mode <- x[which.max(p)]

  return(c("mean" = w.mean, "median" = w.median, "mode" = mode, "sd" = w.sd))
}

#' Expected range of observations
#'
#' Calculates the expected range of n observations drawn from a distribution with
#' standard deviation sd.
#'
#' @param sd numeric; standard deviation.
#' @param n integer; number of observations.
#' @return Numeric value with the expected range of the observation values,
#'   i.e. the difference between maximum and minimum value.
#' @author Andrew Dolman <andrew.dolman@awi.de>
#' @examples
#' ExpectedRange(5, 15)
#'
#' \dontrun{
#' library(tidyverse)
#' f <- function(x, n) n * x * pnorm(x)^(n - 1) * dnorm(x)
#' ests <- expand.grid(mean = 0, sd = 2, n = 15, rep = 1:1000, i = 1:15) %>%
#'   mutate(rdv = rnorm(n(), mean, sd)) %>%
#'   group_by(mean, sd, n, rep) %>%
#'   summarise(sd_hat = sd(rdv),
#'             obs.range = diff(range(rdv))) %>%
#'   group_by(mean, sd, n, rep) %>%
#'   mutate(sd.range = 2*sd_hat*integrate(f,-Inf,Inf, n = n)$value,
#'          exp.range = ExpectedRange(sd, n))
#' ests %>%
#'   gather(estimate, value, -mean, -sd, -n, -rep, -sd_hat, -exp.range) %>%
#'   ggplot(aes(x = estimate, y = value)) +
#'   geom_boxplot() +
#'   geom_hline(aes(yintercept = exp.range)) +
#'   facet_wrap(~n)
#'   }
#' @export
ExpectedRange <- function(sd, n) {

  f <- function(x, n) {n * x * stats::pnorm(x)^(n - 1) * stats::dnorm(x)}

  exp.range <- 2 * sd * stats::integrate(f, -Inf, Inf, n = n)$value

  return(exp.range)
}
